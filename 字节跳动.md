# 【Golang开发面经】字节跳动（三轮技术面）

# 写在前面

> 整体面试下来，**`感觉其实字节对于语言本身并没有很多的涉及`**，更加注重基础，**比如数据结构与算法，计算机网络，组成原理，操作系统，数据库等等**，语言本身并没有涉及太多。

这里就省去了一些我简历上的问题，也就是深挖项目。

# 笔试
略

# 一面
- epoll、select、poll 区别

select 机制刚开始的时候，需要把 fd_set 从`用户空间拷贝到内核空间`，并且检测的 fd 数是有限制的，由 `FD_SETSIZE` 设置，一般是1024。`数组实现`。

poll 的实现和 select 非常相似，只是描述 fd集合 的方式不同，poll使用 `pollfd结构 `而不是 select的 fd_set 结构，其他的都差不多。`链表实现`。

epol l引入了 `epoll_ctl系统调用`，将高频调用的 epoll_wait 和低频的 epoll_ctl 隔离开。epoll_ctl 通过(EPOLL_CTL_ADD、EPOLL_CTL_MOD、EPOLL_CTL_DEL)三个操作来分散对需要监控的fds集合的修改，做到了有变化才变更，**将select或poll高频、大块内存拷贝(集中处理)变成epoll_ctl的低频、小块内存的拷贝(分散处理)，避免了大量的内存拷贝。** epoll使用 `红黑树` 来组织监控的fds集合

- epoll 的水平触发和边缘触发的区别

Edge Triggered (ET) 边沿触发：
1. **socket 的接收缓冲区状态变化时触发读事件，即空的接收缓冲区刚接收到数据时触发读事件。**
2. **socket 的发送缓冲区状态变化时触发写事件，即满的缓冲区刚空出空间时触发读事件。**
3. **仅在缓冲区状态变化时触发事件。**

Level Triggered (LT) 水平触发：

1. **socket 接收缓冲区`不为空`，有数据可读，则读事件一直触发。**
2. **socket 发送缓冲区`不满可以继续写入数据`，则写事件一直触发。**

- TCP 的流量控制

因为我们总希望数据传输的更快一些。但如果`发送方把数据发得过快`，接收方就可能`来不及接收`，这就会造成数据的丢失。流量控制（flow control）就是**让发送方的发送速率不要太快，要让接收方来得及接收。**

利用`滑动窗口机制`可以很方便地在 TCP连接上实现**发送方流量控制**。通过接收方的**确认报文中的窗口字段**，发送方能够`准确地控制发送字节数。`

- 为什么有了流量控制还要有拥塞控制?

流量控制是避免发送方的数据填满接收方的缓存，但并不知道网络中发生了什么。

计算机网络是处在一个**共享**的环境中。因此也有可能会发生网络的拥堵。在网络出现拥堵时，如果继续发送大量的数据包，可能会导致数据包`时延`、`丢失`，这时 TCP 就会`重传数据`，但是⼀重传就会导致网络的负担更重，于是会导致`更大的延迟以及更多的丢包`。

控制的目的就是**避免发送方的数据填满整个网络**。为了在发送方调节所要发送数据的数据量，定义了⼀个叫做「拥塞窗口」的概念。**拥塞窗口 cwnd 是发送方维护的⼀个的状态变量，它会根据网络的拥塞程度动态变化的。**

- TCP 不是可靠传输吗？为什么会丢包呢？

TCP的可靠传输是会在丢包的时候进行重传，来形成可靠的传输，丢包这是网络的问题，而不是TCP机制的问题。

- 那你介绍一下拥塞控制的算法？

拥塞控制一共有四个算法：
1. 慢启动：TCP 在刚建立连接完成后，首先是有个慢启动的过程，这个慢启动的意思就是⼀点⼀点的提高发送数据包的数量。慢启动的算法规则：当`发送方每收到⼀个 ACK，拥塞窗⼝ cwnd 的大小就会加 1`。
2. 拥塞避免：当拥塞窗口 cwnd「超过」`慢启动门限 ssthresh `就会进⼊拥塞避免算法。那么进⼊拥塞避免算法后，它的规则是：**每当收到⼀个 ACK 时，cwnd 增加 1/cwnd**。
3. 快重传：当接收方发现丢了⼀个中间包的时候，`发送三次前⼀个包的ACK`，**于是发送端就会快速地重传，不必等待超时再重传。**
4. 快恢复：快重传和快恢复⼀般同时s使用，快速恢复算法是认为，你还能`收到 3 个重复的 ACK `说明网络也不那么糟糕，所以没有必要像 RTO 超时那么强烈。**进⼊快速恢复之前， cwnd 和 ssthresh 已被更新了：cwnd = cwnd/2 ，也就是设置为原来的⼀半; ssthresh = cwnd 。**

- 进程、线程的区别

| 进程 | 线程 |
|--|--|
| 系统中正在运行的一个应用程序 | 系统分配处理器时间资源的基本单元 |
| 程序一旦运行就是进程 | 进程之内独立执行的一个单元执行流 |
| 资源分配的最小单位| 程序执行的最小单位 |

进程有`独立的地址空间`，一个进程崩溃后，在`保护模式下不会对其它进程产生影响`，而线程只是一个进程中的不同执行路径。

线程有自己的**堆栈和局部变量**，但线程`没有单独的地址空间`，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在`进程切换`时，耗费资源较大，效率要差一些。但对于一些 **`要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程`**

- Go里面GMP模型是怎么样的？

G：表示goroutine，存储了goroutine的执行stack信息、goroutine状态以及goroutine的任务函数等；另外G对象是`可以重用`的。
P：表示逻辑processor，P 的数量决定了系统内最大可并行的 G 的数量（前提：系统的物理cpu核数 >= P的数量）；P的最大作用还是其拥有的各种G对象队列、链表、一些cache和状态。
M：M 代表着真正的执行计算资源，物理 Processor。

> G 如果想运行起来必须依赖 P，因为 P 是它的`逻辑处理单元`，但是 P 要想真正的运行，他也需要与 M 绑定，这样才能真正的运行起来，`P 和 M 的这种关系就相当于 Linux 系统中的用户层面的线程和内核的线程是一样的`。

![在这里插入图片描述](https://img-blog.csdnimg.cn/ced7c30900e94e9db88417483971df45.png)


- 算法：旋转矩阵，牛客上写过，easy，秒

# 二面
- 如何用栈实现队列


- 如何判断一个链表有没有环？


- 为什么快慢指针一定能够相遇？

- 快慢指针相遇的时候，慢指针少走了多少？

- B和B+数的区别是？

- 介绍一下死锁是怎么产生的

- 如何实现互斥锁？

- 如何实现信号量？

- 如何实现自旋锁？

- 算法：三数之和。秒


# 三面
- kafka 和 其他消息队列，比如 rocketmq，rabbitmq ，有什么优势？

- kafka如何保证消息不丢失？

- https为什么是安全的？

- ssl/tls 是怎么保证安全的？经过几次握手？

- 事务的四大特性？

- mysql 的默认隔离等级为什么是 RR？

- 用过哪些排序？

- 快排一定最快吗？

- 场景题：如果我有100G文件，但是只有 500 M 的内存，如何进行排序？

- 算法：最长有序括号

