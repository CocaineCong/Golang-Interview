# 【Golang开发面经】360（一轮游）

# 写在前面
> 这个公司估计是走个形式....

# 笔试
略

# 一面
## TCP 和 UDP 区别
TCP 是可靠传输，面向连接，基于流，占用资源多，效率低。

UDP是尽最大努力交付，基于无连接，基于报文，UDP 占用系统资源较少，效率高。

## UDP能可靠传输吗？
可以的，我们只需要仿照TCP的可靠传输机制就可以了，比如说设置ACK确认机制，一旦没有收到，或是收到三次上一个报文的ACK，我们就立即重传丢失的报文。再比如说设置滑动窗口来保证数据传输的安全性等等...
## MYSQL的隔离等级
- 未提交读（READ UNCOMMITTED）：`READ UNCOMMITTED` 提供了事务之间最小限度的隔离。除了容易产生虚幻的**读操作和不能重复的读操作**外，处于这个隔离级的事务可以读到其他事务还没有提交的数据，如果这个事务使用其他事务不提交的变化作为计算的基础，然后那些未提交的变化被它们的父事务撤销，这就导致了大量的数据变化。
- 提交读（READ COMMITTED）：READ COMMITTED 隔离级别的安全性比 REPEATABLE READ 隔离级别的安全性要差。处于 READ COMMITTED 级别的事务可以看到其他事务对数据的修改。**也就是说，在事务处理期间，如果其他事务修改了相应的表，那么同一个事务的多个 SELECT 语句可能返回不同的结果。**
- 可重复读（REPEATABLE READ）：在可重复读在这一隔离级别上，事务不会被看成是一个序列。不过，当前正在执行事务的变化仍然不能被外部看到，也就是说，`如果用户在另外一个事务中执行同条 SELECT 语句数次，结果总是相同的。`（因为正在执行的事务所产生的数据变化不能被外部看到）。
- 序列化（SERIALIZABLE）：如果隔离级别为序列化，则用户之间通过一个接一个顺序地执行当前的事务，`这种隔离级别提供了事务之间最大限度的隔离。`

## 左连接，右连接有什么区别？

左连接：`只要左边表中有记录，数据就能检索出来`，而右边有的记录必要在左边表中有的记录才能被检索出来。
右连接：右连接是只要右边表中有记录，数据就能检索出来。

右连接与左连接相反，左连接`A LEFT JOIN B`，连接查询的数据，在A中必须有，在B中可以有可以没有。右连接`A INNER JOIN B`，在A中也有，在B中也有的数据才能查询出来。

左连接是已左边表中的数据为基准，若左表有数据右表没有数据，则显示左表中的数据右表中的数据显示为空。右联接是**左向外联接的反向联接**，将返回右表的所有行。如果右表的某行在左表中没有匹配行，则将为左表返回空值。

## JOIN的性能一定好吗？

1. 小表在前可以提高sql执行效率。

2. 尽量不要使用where语句。
![在这里插入图片描述](https://img-blog.csdnimg.cn/5daa9d1fde604f9889f5eb9ec91589c5.png)

> 从上面例子可以看出，尽可能满足ON的条件，而少用Where的条件。从执行性能来看第二个显然更加省时。

3. Inner join 是不分`主从表`的，结果是取两个表针对 On 条件相匹配的最小集。如果是很大的表，首先针对两张表做Where条件筛选，然后再做 Join。

## 线程的通信方式？
消息队列、内存共享、信号
## 快排原理？堆排呢？
快速排序实现的重点在于`数组的拆分`，通常我们将数组的第一个元素定义为比较元素，然后将数组中小于比较元素的数放到左边，将大于比较元素的放到右边，这样我们就将数组拆分成了左右两部分：小于比较元素的数组；大于比较元素的数组。**我们再对这两个数组进行同样的拆分，直到拆分到不能再拆分，数组就自然而然地以升序排列了。**

堆排序的基本思想是：`将待排序序列构造成一个大顶堆`，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余 n-1 个元素重新构造成一个堆，这样会得到n个元素的次小值。**如此反复执行，便能得到一个有序序列了。**


## 算法：top k 问题


估计是不招人了，一面后一点消息也没有。。。