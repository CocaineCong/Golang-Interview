# 关于MySQL的一些面试题

# 1. 内，左，右，全连接
## 1.1 内连接
**内连接：inner join **

返回的是两个表之间的`交集`

## 1.2 左连接
**内连接：left join **

返回的是左表的内容，右边中不符合条件的内容不会显示。

## 1.3 右连接
**内连接：right join **

返回的是右表的内容，左边中不符合条件的内容不会显示。
## 1.4 全连接
关键词：**union / union all**

1. 通过union连接的SQL，它们分别取出的列数必须相同；
2. 不要求合并的表列名称相同时，以第一个sql 表列名为准；
3. 使用union 时，完全相等的行，将会被合并，由于合并比较耗时，一般不直接使用 union 进行合并，而是通常采用union all 进行合并；
4. 被union 连接的sql 子句，单个子句中不用写order by ，因为不会有排序的效果。但可以对最终的结果集进行排序；

# 2. redo，undo，bin 三大日志的用法
- redo log：重做日志，用于记录数据修改后的记录，顺序记录
- undo log：回滚日志，undo日志用于存放数据被修改前的值。用于回滚，保证了事务的一致性。

当 buffer pool 中的 dirty page 还没有刷新到磁盘的时候，发生crash，启动服务后，**可通过redo log 找到需要重新刷新到磁盘文件的记录**；

buffer pool 中的数据直接flush到disk file，是一个随机IO，效率较差，**而把buffer pool中的数据记录到redo log，是一个顺序IO，可以提高事务提交的速度**


- bin log：用于主从复制的交互的日志文件

# 3. MVCC的理解
维持一个数据的多版本，使读写操作没有冲突。
1. 首先是获得事务版本号
2. 获取一个`readView`
3. 查询到数据与readView的事务版本号进行对比
4. 不匹配的话就从`undo log`里获取历史版本数据
5. 返回符合规则的数据。



# 4. MySQL 用索引和不用索引的时间复杂度
- 索引：每个结点 m 分支，log(m)n，另外结点内分 m 区间，二分查找，所以 m*log(m)n。m 是常数，所以 log（m）n。
- 不用索引：o(n) 底层是双向链表

# 5. MySQL的锁的实现


# 6. MySQL 的隔离级别
隔离级别	| 读数据一致性		| 脏读		| 不可重复读		| 幻读
--|--|--|--|--|
未提交读（Read uncommitted）		| 最低级别，只能保证不读取物理上损坏的数据，事务可以看到其他事务没有被提交的数据（脏数据）		| 是	| 	是	| 	是
已提交度（Read committed）		| 语句级，事务可以看到其他事务已经提交的数据	| 	否	| 	是	| 	是
可重复读（Repeatable read）	| 	事务级，事务中两次查询的结果相同	 	| 否	| 	否		| 是
可序列化（Serializable）	| 	串行		| 否	| 	否	| 	否
